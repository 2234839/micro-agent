/** 测试用例配置接口 */
export interface TestCase {
  id: string;
  name: string;
  description: string;
  prompt: string;
  expectedTokens?: number; // 预期的 token 数量（可选）
  temperature?: number;
  maxTokens?: number;
  category?: string; // 测试分类
  tags?: string[]; // 标签
}

/** 测试套件配置 */
export interface TestSuite {
  id: string;
  name: string;
  description: string;
  testCases: string[]; // 测试用例 ID 数组
}

/** 测试模式 */
export type TestMode = 'sequential' | 'parallel';

/** 默认测试用例配置 */
export const DEFAULT_TEST_CASES: TestCase[] = [
  {
    id: 'short-text',
    name: '短文本生成',
    description: '生成一段简短的介绍文字',
    prompt: '请用100字左右简单介绍一下人工智能的发展历程。',
    expectedTokens: 150,
    temperature: 0.7,
    maxTokens: 200,
    category: '基础生成',
    tags: ['短文本', '介绍', 'AI']
  },
  {
    id: 'medium-text',
    name: '中等文本生成',
    description: '生成一段中等长度的技术说明',
    prompt: '请详细解释机器学习中的过拟合问题，包括产生原因、影响和解决方案，大约300字。',
    expectedTokens: 400,
    temperature: 0.7,
    maxTokens: 500,
    category: '技术解释',
    tags: ['技术', '机器学习', '解释']
  },
  {
    id: 'long-text',
    name: '长文本生成',
    description: '生成较长的分析性内容',
    prompt: '请深入分析区块链技术的优缺点，包括技术原理、应用场景、安全性和未来发展，预计500字以上。',
    expectedTokens: 700,
    temperature: 0.8,
    maxTokens: 1000,
    category: '深度分析',
    tags: ['长文本', '区块链', '分析']
  },
  {
    id: 'code-generation',
    name: '代码生成',
    description: '复杂算法实现与多语言测试',
    prompt: `作为一个高级软件开发工程师和AI助手，请你完成以下综合性的代码生成任务。这个测试将评估你在多个编程语言中的代码生成能力、算法理解、注释质量和代码组织能力。

【主要任务：高级排序算法实现】
请用Python、JavaScript和Java三种语言分别实现一个高性能的快速排序算法，要求包含以下特性：

1. **算法实现要求**：
   - 实现标准的快速排序算法（QuickSort）
   - 包含多种优化策略：三数取中、小数组插入排序、尾递归优化
   - 添加详细的性能分析，包括时间复杂度和空间复杂度的理论分析与实际测试
   - 提供完整的单元测试用例，覆盖边界条件、随机数据、已排序数据、逆序数据等场景

2. **代码质量要求**：
   - 遵循各语言的编码规范和最佳实践
   - 添加详细的类型注解（Python使用typing，Java使用泛型）
   - 包含完整的文档字符串（docstring）和注释
   - 实现错误处理和异常管理
   - 考虑线程安全和并发场景

3. **扩展功能要求**：
   - 实现一个可视化算法执行过程的工具函数
   - 提供算法性能对比分析，与冒泡排序、归并排序的对比
   - 实现一个自定义比较器支持，可以排序不同类型的数据结构
   - 添加内存使用情况监控和报告

【辅助任务：系统设计题】
基于快速排序算法，设计一个分布式排序系统，要求：

1. **架构设计**：
   - 描述系统的整体架构，包括数据分片、任务调度、结果合并
   - 设计API接口和数据协议
   - 考虑容错机制和负载均衡

2. **性能优化**：
   - 分析大规模数据下的性能瓶颈
   - 提出优化策略和实施方案
   - 评估不同数据分布情况下的性能表现

3. **实际应用场景**：
   - 列举至少5个实际应用场景，说明算法选择理由
   - 针对每个场景提供具体的实现建议和优化方案

【测试和验证要求】：
1. 提供至少10个不同的测试用例
2. 包含性能基准测试（benchmark）
3. 提供代码覆盖率报告
4. 包含内存泄漏检测和资源使用分析

请确保你的回答包含完整、可运行的代码，详细的说明文档，以及测试结果分析。代码应当是生产就绪的，能够直接在实际项目中使用。`,
    expectedTokens: 2500,
    temperature: 0.2,
    maxTokens: 3000,
    category: '代码生成',
    tags: ['代码', 'Python', 'JavaScript', 'Java', '算法', '系统设计']
  },
  {
    id: 'creative-writing',
    name: '创意写作',
    description: '多类型创意内容生成测试',
    prompt: `作为一个富有创意的AI写作助手，请你完成以下多元化的创意写作任务。这个测试将评估你的创意表达能力、叙事技巧、情感描绘和语言多样性。

【任务一：科幻小说创作】
请创作一个完整的时间旅行科幻短篇故事，要求包含以下元素：

1. **故事框架要求**：
   - 字数：1500-2000字的完整故事
   - 主题：时间旅行中的蝴蝶效应和道德困境
   - 结构：包含开头、发展、高潮、结局的完整情节
   - 人物：至少3个有鲜明个性的主要角色

2. **情节要素**：
   - 一个独特的时间旅行机制（不同于传统的时光机）
   - 一个核心的道德选择，涉及改变历史的后果
   - 两次以上的时间跳跃，每次都有不同的发现
   - 一个意想不到的结局转折

3. **写作技巧要求**：
   - 丰富的感官描写（视觉、听觉、触觉等）
   - 生动的对话，展现人物性格
   - 恰当的节奏控制和悬念设置
   - 科学概念的合理融入

【任务二：诗歌创作】
请创作三首不同风格的现代诗：

1. **第一首：关于人工智能的思考**
   - 形式：自由诗，20-30行
   - 主题：AI与人类关系的哲学思考
   - 要求：运用比喻、拟人等修辞手法

2. **第二首：都市生活的碎片**
   - 形式：散文诗，描述城市中的瞬间
   - 主题：现代都市人的孤独与连接
   - 要求：意象丰富，语言凝练

3. **第三首：自然与科技的对立**
   - 形式：格律诗或半格律诗
   - 主题：传统自然与现代文明的冲突
   - 要求：韵律和谐，意境深远

【任务三：戏剧独白】
创作一个戏剧角色的独白，要求：

1. **角色设定**：
   - 一个面临重大人生抉择的角色
   - 背景可以是历史人物或虚构角色
   - 年龄、性别、时代背景自定

2. **独白要求**：
   - 长度：800-1200字
   - 情感层次丰富：从纠结到决断
   - 包含内心独白和想象中的对话
   - 展现角色的价值观和世界观

3. **戏剧技巧**：
   - 运用停顿和重复来营造戏剧效果
   - 通过具体细节来暗示背景故事
   - 语言风格符合角色身份和时代

【任务四：创意散文】
写一篇关于"记忆"的创意散文：

1. **主题探索**：
   - 记忆的本质和可靠性
   - 个人记忆与集体记忆的关系
   - 数字时代对记忆的影响

2. **写作要求**：
   - 1000-1500字
   - 结合个人经历和哲学思考
   - 运用非线性叙事结构
   - 语言优美，富有诗意

【创意评估标准】：
1. 原创性和独特性
2. 情感表达的深度
3. 语言运用的技巧
4. 结构安排的合理性
5. 主题思想的深刻性

请按照上述要求完成所有写作任务，每个部分都要有明确的标题。你的作品将根据创意性、文学性、情感表达和语言技巧进行评估。`,
    expectedTokens: 2800,
    temperature: 0.9,
    maxTokens: 3500,
    category: '创意写作',
    tags: ['创意', '科幻', '故事', '诗歌', '戏剧', '散文']
  },
  {
    id: 'qa-explanation',
    name: '问答解释',
    description: '深度技术问答与多维度解释',
    prompt: `作为一个专业的AI知识解答助手，请你以问答的形式详细解释量子计算技术。这个测试将评估你的知识深度、解释能力、教学技巧和复杂概念的简化能力。

【量子计算深度解析 - 问答形式】

**Q1: 什么是量子计算？它与经典计算有什么根本区别？**
请详细解释量子计算的基本定义，并与经典计算进行对比分析：
- 量子比特与经典比特的区别
- 量子叠加态和量子纠缠的概念
- 为什么量子计算能够实现并行计算
- 量子计算在处理特定问题时的优势

**Q2: 量子计算机是如何工作的？**
请分步骤解释量子计算机的工作原理：
- 量子比特的物理实现方式（超导、离子阱、光量子等）
- 量子门操作的基本原理
- 量子算法的执行过程
- 量子纠错机制
- 量子测量和结果读取

**Q3: 有哪些著名的量子算法？它们解决了什么问题？**
详细介绍至少4种重要的量子算法：
- Shor算法：大数分解和密码学应用
- Grover算法：无序搜索加速
- 量子傅里叶变换及其应用
- 量子模拟算法及其在化学和材料科学中的应用
- 每种算法的时间复杂度分析和实际应用场景

**Q4: 量子计算目前面临哪些技术和工程挑战？**
深入分析量子计算发展的主要障碍：
- 量子退相干问题及其解决方案
- 量子比特的可扩展性挑战
- 量子纠错的复杂性和开销
- 量子计算机的制造工艺挑战
- 软件和编程工具的发展现状

**Q5: 量子计算在哪些领域有潜在的应用前景？**
详细探讨量子计算的应用方向：
- 密码学和网络安全（威胁与机遇）
- 药物发现和材料科学
- 金融建模和优化问题
- 人工智能和机器学习
- 气候模拟和科学研究

**Q6: 目前全球量子计算发展的现状如何？**
提供最新的行业发展信息：
- 主要科技公司的研究进展（Google、IBM、Microsoft等）
- 各国政府的量子计划和政策
- 创业公司和生态系统发展
- 量子云平台的现状和可及性

**Q7: 学习量子计算需要哪些基础知识？**
为初学者提供学习路径建议：
- 必备的数学基础（线性代数、概率论、复数理论）
- 物理学基础要求
- 编程技能和工具
- 推荐的学习资源和课程
- 从入门到进阶的学习计划

**Q8: 量子计算的伦理和社会影响是什么？**
讨论量子计算带来的社会问题：
- 对现有加密体系的威胁
- 量子优势可能带来的权力集中
- 量子技术的军事应用
- 量子计算发展与隐私保护
- 如何确保量子技术的和平利用

**Q9: 如何看待量子计算的商业化前景？**
分析量子计算的商业化时间表：
- 短期（1-3年）的应用可能性
- 中期（5-10年）的发展预期
- 长期（10年以上）的终极目标
- 投资风险和机会分析
- 传统企业应该如何准备量子时代

**Q10: 量子计算与其他前沿技术（如AI、区块链）的结合点是什么？**
探讨技术融合的可能性：
- 量子机器学习的理论和实践
- 量子安全加密和区块链
- 量子计算在云计算中的角色
- 量子-经典混合计算模式
- 未来技术生态的发展趋势

【回答要求】：
1. 每个问题的回答应该详细但不冗余，控制在300-500字
2. 使用通俗的语言解释复杂概念，适当使用类比
3. 提供具体的例子和实际应用场景
4. 保持科学准确性，避免过度夸大
5. 在适当的地方引用最新的研究成果和数据
6. 为进一步学习提供资源推荐

请按照问题的顺序逐一回答，确保每个回答都独立完整且逻辑连贯。你的回答应该既能满足初学者的理解需求，也能为有一定背景的读者提供深度信息。`,
    expectedTokens: 3200,
    temperature: 0.4,
    maxTokens: 4000,
    category: '问答形式',
    tags: ['问答', '量子计算', '科普', '技术解析', '前沿科技']
  },
  {
    id: 'comparative-analysis',
    name: '对比分析',
    description: '前端框架深度对比与技术选型分析',
    prompt: `作为一个资深的前端技术专家，请你提供一份全面的React、Vue、Angular三大前端框架深度对比分析报告。这个测试将评估你的技术深度、分析能力、实战经验和前瞻性思维。

【前端框架对比分析报告】

**第一部分：核心架构对比**

1. **设计哲学与架构模式**
   - React：函数式编程理念与单向数据流
   - Vue：渐进式框架设计与响应式系统
   - Angular：完整的企业级框架与依赖注入
   - 三者在组件化、状态管理、数据绑定方面的设计差异

2. **技术实现对比**
   - Virtual DOM实现方式的异同
   - 响应式系统的底层原理（Proxy vs Object.defineProperty vs Zone.js）
   - 组件生命周期管理机制
   - 渲染优化策略对比

**第二部分：性能深度分析**

1. **运行时性能对比**
   - 初始渲染性能测试数据
   - 更新性能和大数据量处理能力
   - 内存使用情况分析
   - 包大小对加载性能的影响

2. **开发性能对比**
   - 热重载和开发服务器性能
   - TypeScript支持和类型安全
   - 调试工具和开发体验
   - 构建工具和优化策略

3. **性能优化策略**
   - 各框架的性能优化最佳实践
   - 代码分割和懒加载实现
   - 缓存策略和优化技术
   - 移动端性能适配

**第三部分：生态系统对比**

1. **社区规模与活跃度**
   - GitHub stars、贡献者数量、Issue响应时间
   - NPM下载量和第三方库数量
   - 技术大会、培训资源和学习材料
   - 企业采用情况和成功案例

2. **核心库和工具链**
   - 状态管理解决方案（Redux vs Vuex vs NgRx）
   - 路由系统的功能和易用性
   - UI组件库生态（Ant Design vs Element Plus vs Angular Material）
   - 开发工具和调试支持

3. **第三方集成**
   - 与后端框架的集成能力
   - 移动端开发支持（React Native vs NativeScript vs Ionic）
   - 桌面应用开发方案
   - 微前端架构支持

**第四部分：学习曲线与开发体验**

1. **入门难度分析**
   - 基础知识要求和前置技能
   - 官方文档质量和学习资源
   - 概念复杂度和抽象层次
   - 第一个项目搭建时间对比

2. **进阶学习路径**
   - 高级特性掌握难度
   - 最佳实践和设计模式
   - 性能优化和调试技能
   - 架构设计能力培养

3. **团队协作**
   - 代码规范和最佳实践
   - 大型项目组织结构
   - 多人协作和代码审查
   - 知识传承和团队培养

**第五部分：适用场景分析**

1. **项目规模和复杂度**
   - 小型快速原型开发
   - 中型企业级应用
   - 大型复杂系统
   - 微服务和分布式应用

2. **行业和应用场景**
   - 电商和内容管理系统
   - 金融和企业管理系统
   - 社交媒体和实时应用
   - 数据可视化和仪表板

3. **团队和技术栈考虑**
   - 团队技能背景和学习成本
   - 与现有系统的集成
   - 长期维护和技术演进
   - 招聘和人才市场

**第六部分：未来发展趋势**

1. **技术演进方向**
   - 框架版本更新计划和路线图
   - 新特性预览和实验性功能
   - Web标准和底层技术影响
   - 跨平台开发能力扩展

2. **新兴技术融合**
   - WebAssembly和原生模块集成
   - 服务端渲染（SSR）和静态生成（SSG）
   - 边缘计算和无服务器架构
   - AI辅助开发和低代码平台

**第七部分：技术选型建议**

1. **决策框架**
   - 基于项目需求的评估矩阵
   - 风险评估和缓解策略
   - 成本效益分析
   - 长期技术债务考虑

2. **场景化推荐**
   - 初创公司技术栈选择建议
   - 传统企业数字化转型建议
   - 大型互联网公司架构演进
   - 个人开发者和技术爱好者建议

3. **迁移和互操作**
   - 框架间迁移的成本和策略
   - 混合使用的可行性分析
   - 渐进式重构方案
   - 团队技能转换计划

【分析要求】：
1. 提供具体的数据、案例和最佳实践
2. 保持客观中立，避免个人偏好
3. 考虑不同背景开发者的需求
4. 提供可操作的建议和决策依据
5. 预测未来3-5年的发展趋势

请完成这份全面的对比分析报告，确保内容详实、观点平衡、具有实用价值。报告应该帮助技术决策者做出明智的技术选型决策。`,
    expectedTokens: 3000,
    temperature: 0.5,
    maxTokens: 3800,
    category: '对比分析',
    tags: ['前端', 'React', 'Vue', 'Angular', '技术选型', '架构分析']
  },
  {
    id: 'step-by-step',
    name: '步骤说明',
    description: '全栈应用部署与运维完整指南',
    prompt: `作为一个经验丰富的DevOps工程师和全栈开发者，请提供一份完整的Node.js Web应用部署到生产环境的详细指南。这个测试将评估你的技术全面性、实践经验、问题解决能力和系统性思维。

【Node.js生产环境部署完整指南】

**第一阶段：项目准备和本地优化**

1. **代码质量保证**
   - 代码审查和最佳实践检查
   - 单元测试和集成测试覆盖率
   - 性能测试和压力测试
   - 安全漏洞扫描和依赖检查
   - 代码混淆和知识产权保护

2. **应用优化**
   - 生产环境配置管理（环境变量、配置文件）
   - 日志系统设计和日志级别设置
   - 错误处理和异常监控机制
   - 缓存策略设计和实现
   - 数据库连接池和查询优化

3. **Docker化准备**
   - Dockerfile编写最佳实践
   - 多阶段构建优化镜像大小
   - .dockerignore配置
   - 容器健康检查设置
   - 镜像安全扫描和优化

**第二阶段：云服务器环境搭建**

1. **服务器选择和配置**
   - 云服务商对比（AWS、阿里云、腾讯云、Google Cloud）
   - 实例类型选择和规格配置
   - 操作系统选择（Ubuntu、CentOS、Debian）
   - 网络配置和安全组设置
   - 存储方案选择（SSD、HDD、对象存储）

2. **基础环境安装**
   - Node.js版本管理（nvm、n）
   - 数据库安装和配置（MySQL、PostgreSQL、MongoDB、Redis）
   - 反向代理配置（Nginx、Apache）
   - 防火墙配置和安全加固
   - SSL证书申请和配置（Let's Encrypt）

3. **监控和日志系统**
   - 系统监控（CPU、内存、磁盘、网络）
   - 应用性能监控（APM）
   - 日志收集和分析（ELK Stack、Graylog）
   - 告警配置和通知机制
   - 备份策略和恢复方案

**第三阶段：CI/CD流水线搭建**

1. **版本控制管理**
   - Git工作流设计（Git Flow、GitHub Flow）
   - 分支策略和代码合并规范
   - 代码质量检查集成
   - 自动化测试集成

2. **自动化构建**
   - Jenkins/GitLab CI/GitHub Actions配置
   - 构建脚本和依赖缓存
   - 测试执行和报告生成
   - 构建产物管理和版本标记

3. **自动化部署**
   - 蓝绿部署策略
   - 滚动更新和回滚机制
   - 健康检查和流量切换
   - 部署通知和状态追踪

**第四阶段：应用部署实施**

1. **应用服务器部署**
   - PM2进程管理配置
   - 集群模式和负载均衡
   - 环境变量和配置管理
   - 应用启动和监控脚本

2. **数据库部署**
   - 主从复制和读写分离
   - 数据库备份和恢复策略
   - 性能调优和索引优化
   - 数据迁移和版本管理

3. **静态资源处理**
   - CDN配置和加速
   - 静态资源压缩和缓存
   - 图片优化和格式转换
   - 资源版本控制和更新策略

**第五阶段：安全加固**

1. **网络安全**
   - HTTPS强制跳转配置
   - WAF（Web应用防火墙）配置
   - DDoS防护和流量限制
   - API访问控制和限流

2. **应用安全**
   - 输入验证和SQL注入防护
   - XSS和CSRF防护
   - 身份认证和授权机制
   - 敏感数据加密和存储

3. **服务器安全**
   - SSH安全配置和密钥管理
   - 系统用户和权限管理
   - 定期安全更新和补丁管理
   - 入侵检测和审计日志

**第六阶段：性能优化**

1. **应用层优化**
   - 代码性能分析和瓶颈识别
   - 缓存策略优化（Redis、Memcached）
   - 异步处理和队列管理
   - 数据库查询优化

2. **服务器优化**
   - Nginx配置优化和调优
   - 操作系统内核参数调优
   - 文件描述符和连接数限制
   - 内存管理优化

3. **网络优化**
   - CDN配置和边缘缓存
   - 压缩算法和传输优化
   - HTTP/2和HTTP/3配置
   - 域名解析优化

**第七阶段：运维管理**

1. **监控和告警**
   - 应用性能监控配置
   - 业务指标监控设计
   - 异常告警规则设置
   - 故障响应和处理流程

2. **日常维护**
   - 日志轮转和清理策略
   - 数据库维护和优化
   - 系统更新和补丁管理
   - 备份验证和恢复测试

3. **故障处理**
   - 常见问题排查指南
   - 故障恢复预案
   - 灾难恢复方案
   - 性能问题诊断方法

**第八阶段：扩展和演进**

1. **水平扩展**
   - 负载均衡器配置
   - 多实例部署和同步
   - 数据库分片策略
   - 缓存分布式架构

2. **微服务迁移**
   - 服务拆分策略
   - API网关配置
   - 服务发现和注册
   - 分布式配置管理

3. **云原生演进**
   - Kubernetes集群搭建
   - 容器编排和管理
   - 服务网格（Istio）
   - 无服务器架构迁移

【实践要求】：
1. 提供具体的配置文件示例和代码片段
2. 包含常见问题的解决方案和调试技巧
3. 提供成本分析和预算建议
4. 考虑不同规模项目的差异化配置
5. 提供运维工具和自动化脚本推荐

请完成这份详细的部署指南，确保每个步骤都清晰可执行，包含必要的配置示例和最佳实践建议。指南应该适合从初级开发者到资深运维工程师的不同需求。`,
    expectedTokens: 3500,
    temperature: 0.3,
    maxTokens: 4200,
    category: '步骤指导',
    tags: ['部署', 'Node.js', 'DevOps', '运维', '云服务', 'CI/CD']
  }
];

/** 默认测试套件配置 */
export const DEFAULT_TEST_SUITES: TestSuite[] = [
  {
    id: 'quick-test',
    name: '快速测试',
    description: '包含几个基础测试用例，适合快速验证性能',
    testCases: ['short-text', 'code-generation', 'qa-explanation']
  },
  {
    id: 'comprehensive-test',
    name: '综合测试',
    description: '包含多种类型的测试用例，全面评估性能',
    testCases: ['short-text', 'medium-text', 'code-generation', 'creative-writing', 'qa-explanation']
  },
  {
    id: 'performance-stress',
    name: '性能压力测试',
    description: '包含大量输出的测试用例，测试高负载性能',
    testCases: ['long-text', 'comparative-analysis', 'step-by-step']
  },
  {
    id: 'all-tests',
    name: '全部测试',
    description: '包含所有测试用例，最全面的性能评估',
    testCases: DEFAULT_TEST_CASES.map(tc => tc.id)
  }
];

/** 测试配置常量 */
export const TEST_CONFIG = {
  // 默认测试参数
  defaultTemperature: 0.7,
  defaultMaxTokens: 500,

  // 并发限制
  maxParallelTests: 5,

  // 超时设置
  testTimeoutMs: 300000, // 5分钟

  // 重试设置
  maxRetries: 2,
  retryDelayMs: 1000,
};

/**
 * 根据 ID 获取测试用例
 * @param id 测试用例 ID
 * @returns 测试用例或 undefined
 */
export function getTestCaseById(id: string): TestCase | undefined {
  return DEFAULT_TEST_CASES.find(tc => tc.id === id);
}

/**
 * 根据 ID 获取测试套件
 * @param id 测试套件 ID
 * @returns 测试套件或 undefined
 */
export function getTestSuiteById(id: string): TestSuite | undefined {
  return DEFAULT_TEST_SUITES.find(ts => ts.id === id);
}

/**
 * 根据分类获取测试用例
 * @param category 分类名称
 * @returns 该分类下的测试用例数组
 */
export function getTestCasesByCategory(category: string): TestCase[] {
  return DEFAULT_TEST_CASES.filter(tc => tc.category === category);
}

/**
 * 根据标签获取测试用例
 * @param tag 标签名称
 * @returns 包含该标签的测试用例数组
 */
export function getTestCasesByTag(tag: string): TestCase[] {
  return DEFAULT_TEST_CASES.filter(tc => tc.tags?.includes(tag));
}

/**
 * 获取所有可用的分类
 * @returns 分类数组
 */
export function getAllCategories(): string[] {
  const categories = DEFAULT_TEST_CASES.map(tc => tc.category).filter(Boolean);
  return [...new Set(categories)] as string[];
}

/**
 * 获取所有可用的标签
 * @returns 标签数组
 */
export function getAllTags(): string[] {
  const tags = DEFAULT_TEST_CASES.flatMap(tc => tc.tags || []).filter(Boolean);
  return [...new Set(tags)] as string[];
}